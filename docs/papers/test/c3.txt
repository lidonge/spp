The concept of S++ and its Application
The computer software is viewed as a mapping of the real world. The object-oriented manner simulates the world by mapping entities into classes and objects and completes the business modeling through the interaction between the objects [1]. S++ manages the problem from another view. It maps the behavior of the business activities to simulate the reality and carries out the business scenario modeling through different participants involved in the business activities. These are two completely disparate modeling methods. The former first finishes the static model, and then allows the interaction between models; the latter one first builds the model of the active scene and then assigns the actors (participants) to complete the business scene. S++ is a series of inferences based on the observed facts. A few concepts must be clarified:
The concept of action comes from the idea of an object-oriented manner. All object entities can be encapsulated with their own actions to form a complete object. The granularity of the object’s actions can be divided randomly, and there might be no clear business goals and results. 
Behavior is an activity with inherent logic and purpose. Behavior is generally completed by one or more objects (a set of actions), and the behavior must produce business results based on the business goals.
The participants are for the object entities taking part in the behavior. In the S++ method, the behavior exists as the subject, and all the objects (including people) become object participants.
How to distinguish between the two concepts of behavior and action? It can be illustrated by the example of eating. Eating has clear internal logic and purpose (such as lifting hunger), so eating is an act; while opening mouth and chewing may not have a clear purpose (you can eat and also talk or bite things), therefore, it can only be regarded as the action of the human entity. In the act of eating, at least two objects, the person and the food are needed. These two objects are called participants in the act of eating.
Redefining services in SOA
Based on the above concepts, S++ redefines services as a service, which is a summation of a group of business activities [2]. The following model is a conceptual definition of a service:
 
where ‘B’ stands for business activities, which explain the clear business purpose and inherent business logic. It will eventually produce certain business results. Business activities are the product of participants and behaviors, and its physical meaning is the behaviors with participation. The business result targeted by the business goals can be expressed by the following model:
 
Where ‘B’ represents the goal and result of the business activity, ‘p’ represents the business participant, and ‘b’ represents the behavior. Business action B is a business goal achieved by business entity ‘p’ participating in action ‘b’. Since neither ‘p’ nor ‘b’ can accomplish the business goal independently, therefore, it is indispensable to use the product to indicate that (either p or b is zero when there is no behavior or no entity, the business result ‘B’ as a product is then zero).
•	Distribution Law
 
 
•	Commutative Law
 
Distribution law and commutative law are the conclusions drawn from the observation and incomplete induction of the real world. It is easy to understand the distribution law because it conforms to the basic method of division, but the commutative law tells us that there can be no order in the business activities, which violates the intuition. The reason for the inconsistency is that we usually observe business activities in an object-oriented manner. The following S++ method is used to analyze the business activity of hunger relief (eating), and the commutative law can be explained by the independence of the behavior.
Independency of Behavior
For business activity ‘B’, there are two participants, the hunger relief (p1) and food (p2). The act ‘b’ of eating, based on the previous definition, which is as follows:
 
The literal meaning of this formula is that hunger relief is equal to eating by people, including eating by food. If it is analyzed on the basis of the object-oriented method, then it will be undoubtedly unreliable. How to eat food? In fact, the actual physical meaning of this formula is: hunger relief is equal to the rise of the human blood sugar and food consumption. S++ can directly refer to the physical nature of business activities. Once the business activities are decomposed to this granularity, we will find:
•	No necessary causal relationship exists between the rise of human blood sugar and food consumption. These two factors can happen independently. 
•	If we only focus on the business results, then the order of occurrence of the two is not important. (In fact, for automated services, we actually merely focus on the business results. Usually, the services are treated as a black box). The independence of the behavior explains the derivation of the commutative law. Simultaneously, in the process of analyzing the independence of the behavior, it can be found that business activities cannot be subdivided randomly. After reaching a certain granularity, the business activities meet the business goals, which cannot be obtained by continuing to split. It means that business activities are not continuously separable. This characteristic corresponds to the quantum nature of energy. Therefore, S++ defines the behavior with the smallest particle size as quantum behavior, and the corresponding business activity with the smallest particle size is called quantum service.
Automated and manual processes
Commutative law is the mapping of quantum superposition in the virtual world. It is a human instinct to challenge superposition. We need to realize that business processes can be executed out of order and study the essential difference between the automated process and manual process. From the above analysis, we observed that business activities are composed of quantum services, and for the results, the service can be regarded as a black box. Commutative law is based on the manifestation of quantum nature. Business activity can be counted as an uncertain quantum cloud before the observation of its result ‘B’ from the outside world. The state inside the cloud is completely random and only collapses to result ‘B’ at the moment of observation. That is to say, when the result ‘B’ is observed from the outside world (whether it is observed by human or computer), it means that the observer is actually involved in the entire business process, and the observed process is differentiated into two stages by the observer, and that is before and after observation. Therefore, the commutative law losses the function under the observer’s interference.
From the above analysis, it can be concluded that the commutative law merely plays a role in the automated process. The key to distinguish between the automated process and the manual process is not to focus on the involvement of anyone but to analyze the intermediate results of business activities, which further needs to be observed during the execution of the process. In other words, any process that needs to read and check intermediate results is a manual process. The commutative law is an important basic law of S++. To make the business activities conform to the commutative law, the observation of the intermediate results of the business process should be eliminated completely. In fact, the unavoidable observations are caused by technical reasons in most of the real-world sequential processes. However, these observations are unnecessary in the virtual computer world.
Give an example to illustrate how to eliminate observations in the software, such as the business activity of playing sports in the gym. This business activity can be simplified into two quantum services; “Payment and Play”. In reality, some implementations require to pay first. This is because some business activities cannot be reversed. If you allow playing first without payment, then you may experience a loss in certain circumstances because of the inability to pay. In this case, it can be understood that technical means limit business activities. If certain technical means can reverse business activities to the initial state, then there is no need to consider whether the two business activities of paying and playing are in order. Fortunately, in the virtual world, almost all behaviors are reversible. All the business activities are nothing more than changes in the data on the storage medium in the computer so that most of the observations and detections that require intermediate results can be eliminated. 
Quantum entanglement [3]: quantum superposition is the basis of quantum entanglement in S++. When participants take part in a business scenario together, all participants have aroused the entanglement from a quantum perspective to understand. If entanglement can be achieved, at the moment when any participant in the scene makes the changes, then all participants can also be able to change synchronously, which is impossible with the current technical means. In S++ implementation, the process of quantum entanglement in the physical world can be simulated by executing all quantum services in the parallel scenes.
Inference and application of S++ concept
Through knowing the basic concepts of S++, several important inferences can be drawn:
•	Business and technology can be separated into services.
•	Automation services can be performed out of order.
•	Services are invariant in time and space.
•	Zero-couplings happen between quantum services. 
•	Services are polymorphic. 
These inferences are of great significance to the implementation of S++ and provide a feasible solution to the problems that traditional SOA and microservices cannot solve.
Separation of business and technology
In real life, almost all the actions require the participation of tools, and we usually utilize technology to optimize our activities. For example, we use tableware to eat; here, the tableware behaves as a technical participant. With tableware, our eating process is more hygienic and more labor-saving. Another example is that when we drink hot soup, we will use tableware to stir. Stirring will cool the soup quickly to improve the efficiency of our meals. This behavior of stirring is a technical behavior. We find that technical behavior and participants have some characteristics according to our observations. These characteristics are:
•	Technical participants and behaviors do not change the purpose of business activities. Take an example of the business activity of eliminating hunger. The use of chopsticks, knives, and forks, or even direct grasping with hands, has no effect on the purpose of eliminating hunger. All technical methods and tools are designed to help humans in a better way to achieve their business goals, but technology and tools are not the goals.
•	Technical participants and behaviors do not change the results of business activities. For any achievable business goal, there must be one or more optimal tools to help people to get the same business results. As technology develops, increasing optional tools can be chosen. No matter which tableware is used in the business activity of eliminating hunger, the results will be the same, and you will not be on short commons for using chopsticks.
•	Technical activities follow the distribution law, which means that the technical activities can be performed independently. When the technical behavior and participants are integrated into the service, then the mathematical model of the service can be presented as:
 
 
 
Ti represents the items with technology (behavior or participants) in the product. Since these items have no effect on the final result of the business, therefore the value of these items is zero. The separation of technology and business indicates that the technical part can be completely independent for development and maintenance in a business system, and does not need to be mixed with business code. However, the technical activities cannot comply with the commutative law (because the results of the technical activities are usually observed). For example, encryption and decryption of the messages must be performed before or after the business execution. The determination of authority must be run before the business performance, and so on. The separation of technology and business provides great benefits in the development, operation, and maintenance of the business systems.
•	What model you build is what you get: the modeling and implementation of business activities can completely get rid of technical constraints. The traditional system for model development, experiencing the process of requirement, analysis, design, coding, testing, and then launching the business online, has transformed into two independent and unrelated processes, which are modeling process from business experts and meeting technical requirements by technical personnel. 
•	Zero-coding for business modeling: for services that conform to automated processes, the modeling process would not focus on technical implementation and any branching logic, but on defining the participants, behaviors, and making a list. Therefore, the coding is not needed. 
•	Consistency of the service connotation and diversity of the service extension: the business part B in the service reflects the service connotation, and the technical part T reflects the service extension. The diversity of the business is reflected in the richness of changes of T, such as the diversity of payment services. As long as the technology makes a slight change, it may lead to earth-shaking changes in the entire service, but no matter how the service changes, its business connotation is stable and unchangeable, which brings huge benefits to the development of business systems based on S++. In the process of the business modeling of the services, if you merely need to pay attention to the meaning of the service, it will be undoubtedly much simpler for the modelers; similarly, the technical personnel only need to focus on improving the technical capabilities of the system, instead of understanding the business rules.
Out-of-order execution/parallel operation
The greatest benefit based on the commutative law is parallel operation. Automated services can implement parallel operations at the level of quantum service. An unsolvable problem of the microservice architecture is that the granularity of the service decreases, and the performance of the service composition drops down sharply. Assuming the time Ts, presented the time of running service, includes communication time Tc, database transactions time Td, consuming time of the service T0~Tn, and then the time consumed by service calls in different architectural forms can be expressed using a mathematical model. 
•	For the traditional SOA services with high cohesion and loose coupling, the steps required by business activities are generally finished in a database transaction, so the time it takes to call is expressed by the given equation:
 
•	For microservices, since the service granularity is much smaller than SOA. We assume that in the extreme cases, all steps in SOA are split out and called separately, and then we have:
 
•	For S++, the benefits of parallel operation are:
 
It can be concluded from the above three mathematical models that, if the SOA service is used as a benchmark, then the performance of microservices will consume n-1 more times of communication and database transaction times as the granularity decreases, while S++ can speed up to operation with the decrease in granularity.
In the case of microservices, no microservices can independently provide the complete support to business scenarios due to the gradual reduction of the service granularity. Therefore, the combination of services cannot be avoided to be utilized in large quantities. If we do not carry out S++ for modeling, microservices cannot tackle the functioning problems caused by reducing the granularity.
Time and space invariance of service/service de-versioning
To design the business services with the mind of the technical personnel, the version of the service must exist intuitively. However, from the perspective of separation of business and technology, no matter how plentiful the extension of the service is, there is no change in the business connotation after stripping off the technical part. S++ defines this characteristic of service as the time and space invariance. The time and space invariances of services are consistent with the observation of the objective world. For example, the business activity of car maintenance has been advent since ancient times, and no matter how the era changes, the goal and result of this business are still: bad cars go in and good cars come out.
In fact, relying on the intuition to apply the version characteristics of the objects in the process of establishing a service model, has fatal consequences, especially for achieving business requirements through composition. If service A is called by a composite service S, the service S should maintain two versions when service A needs to maintain two versions. This seemingly simple question encountered a huge challenge after the service S is combined with multiple services (such as A, B, and C). If it happens, then A, B, and C all need to maintain two versions, respectively. Does the service S need to maintain the 2x2x2 = 8 versions to cope with the combination of different versions? No, it is not possible. The version of service S provides:
•	The connotation of the service does not allow having versions.
•	Any modification to the connotation of the service will inevitably result in a new service. 
•	The version of the service is only allowed in the external definition of the service.
•	The combination of services can only call the connotation of the service, and it is not allowed to directly call specific extensions (implementation of services).
Zero-coupling between quantum services
If a quantum service A needs to call another service B, then according to the definition we have:
 
A is not a quantum service, so there is no calling relationship between quantum services, which means no coupling.
The description of zero-coupling of quantum services is as follows:
•	Business activities must be realized by the combination of quantum services. 
•	Every coupled business system can be further split into two parts: quantum services and business portfolio
The traditional microservice architecture has a serious problem. As the granularity of the services is refined, the complexity of the service systems increases exponentially. The mutual call between services causes increasing transaction links with the number of services, which will lead to a lot of problems:
•	The reduced maintainability of the system: any modification on the service will cause the associated modification, while the number of the services is still huge.
•	The complexity of the transaction link is uncontrollable, resulting in extreme dependence on the monitoring system.
•	The complexity of the monitoring system has risen extraordinarily, and the demand for resources even exceeds the capacity of the business system. For instance, only one person is working, and a group of people is watching and supervising him or her. 
In this case, S++ provides the following terms and conditions to simplify the transaction link and system complexity:
•	No service can include both the specific business and the calls to other services.
•	Quantum services can only be called by purely composite services.
•	The composite service cannot call each other. The composite services can only be modeled by listing the participants and behaviors.
Service polymorphism
In the object-oriented method, the objects are the business subjects. The types of objects cannot be enumerated, and the instances of the objects cannot be counted. The complexity of system modeling relies on describing the complicated object-relational models. For S++, business behavior is the main part, and the behavior patterns are very few to compare with the objects, further can be enumerated. Now the query arises, how does S++ build a variety of business services using the extremely limited behaviors? It is the participants who determine the business goals and results of the service. For example, for the business behavior of eating, when the participant is a diner, the business goal is to relieve hunger; if the participant is a guest at a business banquet, the business goal becomes social relations, and if the participant is an athlete who fought eating contest, then the business goal is to attain the medals.
The same business behavior leads to different business goals due to different participants. This has shown the polymorphism of the service. The polymorphism leads to a large number of business services in S++ and has similarity to each other.
The service polymorphism can improve the maintainability of business processes and remove the business branches in traditional business processes. The traditional processes need to determine the type of business based on the contents of business and subsequent service calls. In S++, the decision and schedule of business branches are automatically performed by the system, and the different business services are invoked according to the different participants. In case of the business payment of the bank, the traditional business process needs to decide the payment category field, and the content of the field will be identified to conduct the payment of telephone bills, water bills, etc. If you want to add a payment category, you must modify the business process. It remarkably reduces the maintainability of the system; in the business process of S++, we do not need to make the business branch identifications. In the modeling process, only the abstract payment service needs to be answered. During the operational process, the abstract participants are replaced by the actual participants, and then the system will automatically consummate the business branch function.
The principal difference between the S++ service polymorphism and the object-oriented polymorphism is that the object-oriented polymorphism must be conducted on the client side, while S++ polymorphism can be implemented from the server side. This difference is mainly reflected in the different coupling degree of the system. For the object-oriented polymorphism, the client must couple all the known implementation classes, and at the very least, it should be the interface level of the coupling (such as remote objects). Nevertheless, the client of S++ can never know how many specific services are implemented. The service polymorphism is decided by the server according to the messages received., No coupling would happen without abstract services.
The category of services
Services in S++ are divided into two categories: technology class and business class. Each category is further subdivided. 
Technology class
Based on the definition, all actions and participants that have no impact on business goals and results are classified as the technical category. Therefore, technical services can be easily distinguished [].
Calibration services
The calibration services are used for data inspection and verification of the input information of the service to prevent the dirty data from polluting the service system.
Conversion services
Conversion services are used to convert input data in different formats or covert the data with the format specified by the service system or reverse the conversion.
Security services
Security services are primarily performed for encryption of sensitive data, decryption of sensitive data, anti-tampering of messages, system authentication, authority control, and other measures to ensure transaction security.
Error handling services
Error handling services is to intercept business errors and technical errors that occur during service execution through an error interceptor, in order to separate the error handling from business processes and avoid the interference with the business.
Business class
The business services have been classified into five major categories according to the behavior patterns [4] [5]:
Entity maintenance
Even though S++ service and object-oriented service have similarities in the maintenance of entities, there is also the dissimilarity between the S++ service and object-oriented service. The biggest difference is that the entity class of S++ only includes the natural classifications and attributes of the entity. For example, the entity of human can generate a large number of classifications from different dimensions in object-oriented services, such as classification by occupation, age, career, etc., but in S++ service, the only attribute classified by nature is the category of human; therefore, human entities are identified as the class of natural person. The social attributes of human are expressed through the results of contracting behaviors. Natural entities become a participant through contracting. For example, a natural person contract with the company to become employees. Usually, most services are directed to participants rather than natural entities.
Contract Signing
The contract signing is the most common behavior in social activities. Generally, contracts are divided into identification contracts and executable contracts. Identity recognition contracts can be signed between natural entities or mixed between natural entities and participants. The outcome of identity recognition contracts is the formation of new types of participants list in order to meet certain business scenarios. The executable contracts should be signed between participants. Natural entities must be attached to social attributes before they can take part in the signing of an executable contract. An executable contract usually has multiple execution states and results. For instance, an order is an executable contract. The order can be modified, paid, canceled, dispatched, closed, evaluated, etc. The change of the contract status in the S++ service actually produces a new contract.
Quantum service class (generated during contracts execution)
The contract execution services are applied to execute the changes in contract state and contract participant attribute changes. Changes in the contract state will produce the new contracts, and only changes in the attributes of participants will truly affect the physical world. Normally, change in physical quantity in the business environment will only be shown in the form of numbers, such as the inventory quantity, account balance, etc., so, it seems that the quantum services only have two circumstances that are increasing and decreasing.
Query class
The query services are used for query entities, participants, and contracts execution.
Computing class
The computing services should be a part of other business services in a strict sense. For example, the calculation rate is part of charging services, and the charge execution can be conducted after the rate charge is calculated. The purpose of separating computing services from business services is to improve the reusability of computing processes. Therefore, computing services are more closed to technical services. In dealing with the process, the computing class is similar to the technical class. The business calculation work needs to be completed according to the different participants before the initiation of the automatic process.
Others
Service Security
Quantum services in S++ do not have any coupling calls with each other, and all calls come from the combined process of the business scenario, so, S++ is easier to obtain at a low cost in security than traditional SOA and microservices. A simple IP white list is required in quantum services to ensure the legality of access because only a limited number of process control nodes can access the quantum services. As long as the traditional security measures are applied at the entrance of the combined process, the security of the entire system can be ensured.
Data storage method
S++ supports the most comprehensive storage of distributed databases (a centralized storage structure). The data storage layer designed for the characteristics of quantum storage services can exploit the full advantages of S++. In the S++ model, the relationship between objects is greatly weakened, and there is also a limitation in the types of data tables. The current design includes the three types of data tables, such as entity tables, contract tables, and quantum data tables. This database has the following characteristics in comparison with the traditional relational database:
1.	Database services exist in the form of discrete microservices. The centralized database management procedures, which are similar to relational databases, are not required, and there is no strong dependency between the services.
2.	The database service mainly provides three primary service functions, such as entity maintenance, business pipeline maintenance, and quantum service. The traditional function of retrieving content is independent as a third-party indexing service. 
3.	Database records can be accessed through array subscription, especially the data that quantum services need to change. The high-speed random storage devices can be used independently to enhance the performance much higher than the traditional relational libraries.
4.	Except for the quantum data, all data are modified by sequential addition, so you can promote write efficiency by adopting cache.

Reference
1. Suhardi, S., Doss, R., & Yustianto, P. (2015). Service engineering based on service oriented architecture methodology. TELKOMNIKA (Telecommunication Computing Electronics and Control), 13(4), 1466–1477.
2. Carter, S. (2007). The role of business process management in SOA. Information Management, 17(5), 30.
3. Gyongyosi, L., & Imre, S. (2018). Entanglement availability differentiation service for the quantum internet. Scientific reports, 8(1), 1–8.
4. Mahmoud, T., & Gómez, J. M. (2008, April). Integration of semantic web services principles in soa to solve eai and erp scenarios; towards semantic service oriented architecture. In 2008 3rd International Conference on Information and Communication Technologies: From Theory to Applications (pp. 1–6). IEEE.
5. Muthusamy, V., Jacobsen, H. A., Chau, T., Chan, A., & Coulthard, P. (2009, November). SLA-driven business process management in SOA. In Proceedings of the 2009 Conference of the Center for Advanced Studies on Collaborative Research (pp. 86–100).

