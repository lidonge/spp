# S++概念与应用

S++这个概念是在2015年提出的，2016年正式在InfoQ发表。S++重新定义了面向服务，将传统的SOA中的模糊的部分进行了澄清，确定了识别服务最小颗粒度的方法，并给出了服务的数学模型。

# 概念阐述

计算机软件是对现实世界的映射，面向对象通过将实体映射成类和对象来模拟世界，通过对象间的交互来完成业务的建模。S++则从另外一个角度来看待问题，它将业务活动映射成行为来模拟现实，通过不同的参与者参与业务活动来完成业务场景建模。这是两种截然不同的建模方法，前者先完成静态的模型，然后让模型之间互动；后者先建立活动场景的模型，然后加入演员（参与者）完成业务场景。S++是基于观察到的事实（物理学叫测量结果或实证经验）基础上的一系列推论，首先要明确几个概念：

**动作（action）**这个概念来源于面向对象的思想，所有的对象实体都可以与其本身的动作封装在一起，从而形成一个完整的对象。对象的动作的颗粒度是可以随意划分的，并且可以没有明确的业务目标和结果。

**行为（behavior）**是具有内在的逻辑性和目的性的活动，行为一般是由一个或多个对象参与（一组动作）完成，并且行为一定会产生基于业务目标的业务结果。

**参与者（participant）**是参与行为的对象实体，在S++的方法中，行为作为主体存在，而对象（包括人）则都成为客体参与者。

如何区分行为（behavior）和动作（action）这两个概念？可以通过吃饭这个例子来说明，吃饭是具有明确的内在逻辑性和目的性的（比如解除饥饿），所以吃饭是一种行为；而张嘴和咀嚼，由于可能不具备明确的目的性（既可以吃饭也可以说话或咬东西），所以只能视为人这个实体的动作。而吃饭这个行为中，至少要有人和食物这两个客体存在，这两个客体就称为吃饭这个行为的参与者。

## 对SOA中服务的重新定义

基于上述概念，S++重新定义了服务：**服务是一组业务活动的总和**。下面这个模型就是对服务的抽象定义：

<img src="http://latex.codecogs.com/gif.latex?S=\sum_{i=0}^n B_i =\sum_{i=0}^n p_i*b_i" align=center />

其中大写的***B***代表**业务活动**，具有明确的业务目的和内在的业务逻辑，并最终会产生一定的业务结果。业务活动是参与者与行为的乘积，物理含义就是具有参与者参与的行为，其结果就是具有业务目标的业务结果，用如下模型表示：

<img src="http://latex.codecogs.com/gif.latex?B=p*b" align=center />

式 中B代表业务活动的目标和结果，p代表业务参与者（participant）,b代表行为（behavior）。业务行为B是由业务实体p参与行为b而实现的业务目标，由于p和b都不能独立的完成业务目标，所以用乘积的形式来表明缺一不可（当p和b任意一项为零，即没有行为或没有实体时，作为乘积的业务结果B为零）。

- **分配律**

<img src="http://latex.codecogs.com/gif.latex?B=p*(b_1+b_2)=p*b_1+p*b_2=B_1+B_2" align=center />

<img src="http://latex.codecogs.com/gif.latex?B=(p_1+p_2)*b=p_1*b+p_2*b=B_1+B_2" align=center />

- **交换律**
  <img src="http://latex.codecogs.com/gif.latex?B=B_1+B_2=B_2+B_1" align=center />

分配律和交换律都是对现实世界观察和不完全归纳所得出来的结论，其中分配律很容易理解因为它符合分而治之的基本方法；但是交换律告诉我们业务活动可以没有先后次序，这就明显违背了直觉。与直觉不相符的原因是，我们通常都是以面向对象的方式来观察业务活动的。下面用S++的方法来分析解除饥饿（吃饭）这个业务活动，就可以通过行为的独立性来说明交换律。

**行为具有独立性**

对于解除饥饿这个业务活动*B*，有两个参与者人（*p1*）和食物（*p2*），以及进食这个行为*b*，基于前面的定义我们可以得出：
<img src="http://latex.codecogs.com/gif.latex?B=(p_1+p_2)*b=p_1*b+p_2*b=B_1+B_2" align=center />
这个公式的字面意思就是，解除饥饿=人进食+食物进食，如果按照面向对象的方法来分析这无疑是荒谬的，食物如何进食？其实这个公式的实际物理含义是：解除饥饿=人的血糖上升+食物的消耗。S++可以直指业务活动的物理本质，一旦把业务活动分解到这种颗粒度，我们就会发现：

- 人的血糖上升其实和食物的消耗并没有必然的因果关系，这两者完全可以独立的发生。
- 如果我们只关注业务结果的话，其实这两者的发生先后次序也并不重要。（事实上对于自动化服务而言，我们确实只关注业务结果，通常服务都是作为一个黑盒子来对待的）

行为的独立性说明了交换律的来源，同时在分析行为独立性的过程中可以发现，业务活动并不可以随意的细分，到达一定颗粒度后继续拆分就无法获得符合业务目标的业务活动了，也就是说业务活动不是连续可分的。这种特性恰好与能量的量子性相对应，所以S++定义**最小颗粒度的行为为量子行为**，相对应的**最小颗粒度的业务活动称之为量子服务**。

## 自动化流程与人工流程

交换律是**量子叠加性**在虚拟世界的映射，挑战叠加性几乎是人的一种本能，要认识到业务流程可以乱序执行，必须要研究自动化流程和人工流程的本质区别。从上面的分析可以看到，业务活动是由量子服务组成的，并且对于结果而言服务本身可以看作一个黑盒子，交换律的成立其实本质就是量子性的体现。一个业务活动，在外界去观察其结果B之前，可以看作一个不确定的量子云。云内部的状态是完全随机的，只有观察的瞬间才塌缩成结果B。也就是说，当外界去观察结果B的时候（无论是人去观察还是计算机去观察），观察者其实是参与了整个业务流程，流程就被观察者区分为观察前和观察后两个阶段，于是交换律就在观察者的干扰下失去作用了。

从上述分析中可以得出，交换律只在自动化流程中起作用，区分自动化流程与人工流程的关键并不在于是否有人参与，而是流程执行过程中是否需要观察业务活动的中间结果。也就是说，任何需要读取、检查中间结果的流程，都是人工流程。交换律是S++的一个非常重要的基本规律，要让业务活动符合交换律，需要完全的消除对业务过程中间结果的观察，事实上现实世界的顺序流程大多是因为技术原因导致无法避免的观察，但是这些观察在虚拟的计算机世界中可能是不必要的。

举一个例子来说明如何在软件中消除观察，比如去体育馆打球这个业务活动。这个业务活动可以简化成两个量子服务来组成：“缴费+打球”，在现实中有些实现是必须要先缴费，这是因为有些业务活动是无法逆转的，如果先打球再缴费可能会造成无法收到钱这样的损失。这样的情况，可以理解为是技术手段限制了业务活动，如果有一定的技术手段使得业务活动可以逆转到初始状态，那么缴费和打球这两个业务活动有没有顺序就完全不用考虑了。所幸，在虚拟世界中，几乎所有行为都是可逆的，对于计算机而言所有的业务活动无非就是存储介质上的数据的变化，所以几乎所有的需要对中间结果的观察和检测都是可以消除的。

**注：** **量子纠缠**暂时无法在S++中实现，当参与者共同参与一个业务场景时，所有的参与者从量子的角度就产生了纠缠。如果能实现纠缠，那么场景中任何一个参与者发生变化的瞬间，所有参与者也会同步的发生变化，这就目前的技术手段而言是无法实现的。S++实现中，可以通过并行的执行场景中所有的量子服务的方式，模拟物理世界中量子纠缠的过程。

# S++概念的推论和应用

了解了S++的基本概念，可以得出几个重要的推论：

- 服务中业务和技术可以分离
- 自动化服务可以乱序执行
- 服务具有时空不变性
- 量子服务间零耦合
- 服务具有多态性

这些推论都对S++的实现有着重大的意义，对传统SOA和微服务无法解决的问题提供了可行的解决方法。

## 业务和技术分离

现实生活中，几乎所有的行为都需要工具的参与，我们通常会用技术来优化我们的活动。比如我们会使用餐具来吃饭，其中餐具就是技术参与者，有了餐具我们吃饭的过程更加卫生、更加省力。又比如我们在喝热汤的时候，会用餐具来搅拌，搅拌会让汤快速的降温，以提高我们吃饭的效率，搅拌这种行为就是技术行为。通过观察我们发现技术行为和参与者具有一些特性：

- 技术参与者和行为并不改变业务活动的目的。比如解除饥饿这个业务活动，是使用筷子、还是使用刀叉甚至直接用手抓，对解除饥饿的目的是不产生任何影响的。所有的技术手段和工具，都是为了更好的帮助人类完成业务目标，但技术和工具并不是目标本身。
- 技术参与者和行为也不改变业务活动的结果。任何可以达成的业务目标，一定有一种或多种可选择的工具帮助人们去获得同样的业务结果，而且随着技术的进步可选择的工具会越来越多。使用任何餐具在解除饥饿这个业务活动中，得到的结果都是一样的，并不会因为使用了筷子就吃不饱。
- 技术活动遵从分配律，也就是说技术活动可以分开来独立执行。

当服务中融合了技术行为和参与者后，服务的数学模型可以表达为：


<img src="http://latex.codecogs.com/gif.latex?S=B+T=\sum_{i=0}^n B_i+\sum_{i=0}^nT_i" align=center />

<img src="http://latex.codecogs.com/gif.latex?S=\sum_{i=0}^n p_i*b_i+(\sum_{i=0}^n t_i* B_i + \sum_{i=0}^n p_i*t_i+\sum_{i=0}^n t_i*t_i)" align=center />

<img src="http://latex.codecogs.com/gif.latex?S=\sum_{i=0}^n p_i*b_i +0" align=center />

其中Ti代表了乘积中有技术（行为或参与者）的项，由于这些项对业务的最终结果没有影响，所以这些项的值为零。技术和业务分离说明，在一个业务系统中，技术部分可以完全独立出来进行开发和维护，不需要和业务代码相混杂。不过技术活动无法遵从交换律（因为通常要对技术活动的结果进行观察），比如对报文的加解密，必须在业务执行之前或之后执行，权限的判别必须在业务执行之前运行等等。技术和业务分离给业务系统的开发和运维提供了很大的益处：

- **所建（模）即所得**：业务活动的建模和实现，可以彻底摆脱技术的制约。传统的系统开发模式，需求->分析->设计->编码->测试->上线，变成了两个独立的相互无关的过程：业务专家建模过程、技术人员满足技术要求的过程。
- **业务建模零编码**：对于符合自动化流程的服务而言，建模的过程中不再关注任何技术实现，也不需要关注任何分支逻辑，仅仅是将参与者和行为定义出来，并进行简单的罗列。所以，编码的需要是不存在的。
- **服务内涵的一致性和服务外延的多样性**：服务中业务部分B体现了业务的内涵，技术部分T体现了服务的外延。业务的多样性就体现在T的丰富变化之中，比如支付服务所呈现的令人眼花缭乱的多样性。只要技术发生一丁点变化，都有可能导致整个服务发生翻天覆地的变化，但无论服务在形式上如何变化，其业务内涵是稳定不变的，这给业务系统基于S++进行开发带来了巨大的益处。在服务的业务建模过程中，如果只需要关注服务的内涵，那么对于建模人员来说无疑简单了很多；同理，对于技术人员而言也无需再去理解业务规则，只需要专注于提升系统的技术能力即可。

## 乱序执行/并行运算

基于交换律得到的最大的好处，就是并行运算。自动化服务，可以实现在量子服务层级的并行运算。微服务架构的一个无法解决的问题，就是随着服务颗粒度的降低，服务的组合性能急剧下降。假设调用一个服务所必需的时间Ts包括：通讯时间Tc、数据库事务的消耗时间Td以及完成业务所需步骤的时间T0~Tn，那么可以用数学模型表达不同架构形式的服务调用所消耗的时间。

- 对于传统的高内聚松耦合的SOA服务而言，业务活动所需的步骤一般都在一个数据库事务中完成，所以其调用所消耗的时间表达如下：

<img src="http://latex.codecogs.com/gif.latex?T_s=T_c+T_d+\sum_{i=0}^nT_i" align=center />

- 对于微服务而言，由于服务颗粒度比SOA小很多，假设极端情况下是把SOA中的所有步骤都拆分出来分别的调用，那么：

<img src="http://latex.codecogs.com/gif.latex?T_s=\sum_{i=0}^n(T_c+T_d+T_i)" align=center />

- 对于S++而言，并行运算带来的好处就是：

<img src="http://latex.codecogs.com/gif.latex?T_s=T_c+T_d+Max(T_i|_{i=0}^n)" align=center />

通过上面三个数学模型可以看出，如果以SOA服务为基准，微服务的性能随着颗粒度的降低要多消耗n-1个通讯和数据库事务的时间，而S++随着颗粒度的降低运行速度反而会有所提升。

对于微服务而言，由于服务颗粒度的逐步降低，任何一个微服务都无法独立的对外提供完整业务场景的支持，所以服务的组合无法避免的要大量使用，如果不使用S++进行建模，微服务根本无法承受降低颗粒度带来的性能问题。

## 服务的时空不变性/服务去版本化

用一个技术人员的思想来设计业务服务，直觉上服务的版本是必须存在的。但是从业务和技术分离的角度看，无论服务的外延有多丰富，剥离掉技术部分剩下的业务内涵几乎没有任何变化，S++将服务的这种特性定义为**时空不变性**。服务的时空不变性符合对客观世界的观察结果，比如修车这种业务活动，从古至今都有，而且无论时代如何进步，这个业务的目标和结果都是：坏车进去好车出来。

事实上，在建立服务模型的过程中凭直觉的套用对象的版本特性，带来的后果是致命的，尤其是对于通过组合来实现业务需求而言。假如服务A被一个组合服务S调用，那么当服务A需要维护两个版本的时候，服务S理论上也应该维护两个版本。于是这个看似简单的问题在服务S组合了多个服务（比如A, B, C）之后遇到了巨大的挑战，如果恰巧ABC都需要各自维护两个版本，服务S是不是要维护2x2x2=8个版本以应对不同版本的组合？显然这是不可能的事情，于是对于服务的版本S++规定：

- 服务的内涵不允许有版本
- 任何对服务内涵的修改，必然产生新的服务
- 服务的版本只出允许现在服务的外延定义中
- 服务的组合只能调用服务的内涵，不允许直接调用具体的外延（服务的实现）

## 量子服务之间零耦合

假如一个量子服务A，需要调用另外一个服务B，那么根据定义：
<img src="http://latex.codecogs.com/gif.latex?A=p_0*b_0 + B= p_0*b_0 + \sum_{i=1}^nB_i=\sum_{i=0}^nB_i" align=center />
可见A并不是一个量子服务，所以量子服务之间是没有调用关系的，也就是没有任何耦合。量子服务的零耦合说明：

- 业务活动必然由量子服务的组合来实现
- 任何相互耦合的业务系统都可以进一步拆分成量子服务和业务组合两部分

传统的微服务架构有一个严重的问题，就是随着服务颗粒度的细化，服务系统的复杂度呈指数上升。服务之间的相互调用，导致交易链路随着服务数量的增加而急剧增加，这将带来大量的问题：

- 系统的可维护性大大降低：任何服务的修改都必然引起关联的修改，而服务的数量是如此的庞大。
- 交易链路的复杂度不可控，导致对监控系统严重的依赖。
- 监控系统的复杂度急剧上升，对资源的需求甚至超过业务系统本身，就好比一个人干活儿一群人围观监督。

对于这种情况，为了简化交易链路和系统复杂度，S++规定：

- 任何服务不能既包含具体的业务本身，还包含对其他服务的调用。
- 量子服务只能被纯粹的组合服务调用
- 组合服务之间不能相互调用，组合服务只能通过罗列参与者和行为来建模实现。

## 服务的多态性

面向对象的方法中对象为业务主体，对象的种类不能枚举，对象的实例更无法穷尽，系统建模的复杂度就在于描述复杂的对象关系模型。对于S++而言业务行为作为主体，行为模式相对对象种类来说就少的太多，几乎可以枚举。S++是如何运用极其有限的行为建立变化无穷的业务服务的？简单来说，就是参与者决定了服务的业务目标和结果。举个例子来说，对于吃饭这个业务行为，当参与者是食客的时候，业务目标就是解除饥饿；如果参与者是商务宴会的宾客，那么业务目标就变成社交；甚至如果参与者是吃饭大赛运动员，那么业务目标就变成获得奖牌。

**相同的业务行为，因不同的参与者而导致不同的业务目标和结果，这就是服务的多态性**，多态性导致了S++中大量的业务服务是非常相似的。

服务的多态性可以改善业务流程的可维护性，消除掉传统业务流程中的业务分支，传统的业务流程中需要根据业务字段的内容来判断业务种类，并决定后续的服务调用；在S++中，业务分支的判断和调度由系统根据参与者来自动执行，根据参与者的不同自动的调用不同的业务服务实现。举例来说，对于银行的缴费业务，传统的业务流程中要判断缴费类别字段，根据字段内容的不同来调用缴电话费、水费等，所以如果要新增缴费类别就要修改业务流程，这无疑降低了系统的可维护性；S++的业务流程中，无需再做类似的业务分支判断，建模过程中只需调用抽象的缴费服务，运行过程中抽象的参与者被实际的参与者替代后，系统就自动的完成业务分支功能。

S++服务多态性与面向对象的多态性最重要的差异是，面向对象的多态性必须在客户端实现，而S++的多态性可以在服务端实现。这个差异在实现上主要体现在系统的耦合度不同，面向对象为实现多态性，客户端必须耦合所有已知的实现类，最低限度也是interface这个级别的耦合（如远程对象）；而S++的客户端可以完全不知道到底有多少具体的服务实现，服务的多态性是服务端根据收到的报文来决定的，除抽象服务的定义外，没有任何耦合。

## 服务的分类

S++中服务被分为两大类，业务类和技术类，每个大类下又有细分。

### 技术类

根据定义，所有对业务目标和结果不产生影响的行为和参与者，都属于技术范畴。所以，技术类服务很容易被区分出来。

- 校验类服务

  校验类服务主要用于数据的检查，一般用于服务的输入信息的核对，防止脏数据污染服务系统。

- 转换类服务

  转换类服务主要用于将不同格式的输入数据转换成服务系统规定的格式，或逆向的转换。

- 安全类服务

  安全类服务主要用于敏感数据的加解密，报文的防篡改，系统的认证、权限控制等等保证交易安全的措施。

- 错误处理类服务

  错误处理是通过错误拦截器来拦截服务执行过程中发生的业务和技术错误，从而将错误处理从业务流程中独立出来，避免对业务的干扰。

### 业务类

业务类服务主要按行为模式分为五大类：

- 实体维护类

  S++和面向对象在实体的维护上有相似的地方，也有比较大的差异。最大的差异就是，S++的实体类只包括实体的自然分类和属性。例如人这个实体，在面向对象中可以从不同的维度产生大量的分类，如按职业分类、按年龄段分类、按岗位分类等等；但是在S++中，按自然分类属性就只有人这一个类，所有的人的实体都归为自然人这个分类。人的社会属性是通过签约行为产生的结果来表达的，自然实体通过签约成为一个参与者，比如自然人与公司签约成为员工，通常大部分服务都是针对参与者而非自然实体的。

- 签约类

  签约是社会活动中最普遍的行为，大体上合约分为身份认定合约和可执行合约。身份认定类合约可以在自然实体间签署，也可以自然实体与参与者之间混合签署，身份认定类合约的结果就是产生新的类型的参与者，目的是为了满足一定的业务场景。可执行类合约一定是在参与者之间签署的，自然实体必须附加上社会属性才可能参与签署一个可执行的合约。一个可执行的合约，通常有多种执行的状态和结果，比如订单就是可执行合约，订单可以被修改、支付、取消、派送、关闭、评价等等。

- 合约执行类

  合约执行类服务用于可执行合约的状态变迁，以及合约参与者属性的改变。

- 查询类

  查询类服务用于查询实体、参与者以及契约执行结果。

- 计算类

  计算类服务严格意义上应属于其他类业务服务的一部分，比如计算费率就是收费服务的一部分，而且收费必须在计算费率之后才能得到确切的费率执行。把计算类服务从业务服务中剥离出来的目的就是为了提高计算过程的复用性，所以计算类服务更像是技术服务。在流程处理上，计算类也类似于技术类，需要在自动流程发起前根据参与者的不同完成业务计算工作。

## 其他

### 服务的安全性

由于S++中的量子服务相互没有任何耦合调用，所有调用都来自业务场景的组合流程，所以S++在安全性上比传统的SOA和微服务更容易低成本的获得。对于量子服务而言，只需要做简单的IP白名单校验就可以保证访问的合法性，因为只有有限的几个流程控制节点可以访问量子服务。只要在组合流程的入口应用传统的安全措施，就可以确保整个系统的安全性。

### 数据存储方式

S++支持最彻底的分布式存储（当然也可以使用集中式的存储结构），针对量子服务的特点设计的数据存储层，可以更大的发挥S++的优势。更详细的说明请详见[《S++分布式数据库需求及参考设计》](./db.md)  。

相对于面向对象的建模方式，S++的建模方式更有利于数据的分布式存储。在S++模型中，对象之间的关系被大幅度的弱化了，数据表的类型也很少，基本上只有实体表、身份类契约表、可执行契约表和各类的业务流水表。所以，如果在S++分布式的数据架构下实现面向商业智能的复杂关系型应用，是非常具有挑战性的。当然，S++也可以构建在单一的关系型数据库上，这样的架构设计就可以满足复杂的关系运算，但是单一的数据库无法满足高并发的业务场景。一个折中的选择就是用空间换取时间，利用与业务系统并行的数据处理系统来完成商业智能类的实时数据存储。

- 量子服务都是单表操作。由于量子服务之间的无关性，每一个量子服务只需要访问单一的数据表。
- 数据表之间无需建立关联关系。无表间关系的数据存储结构有利于分表操作，可以实现更灵活的动态分表策略。
- S++分布式数据存储不支持在数据层的关联查询，关联查询只能在服务场景层实现。

### 推荐的分层结构

依据不同的服务颗粒度，S++推荐采用分布式的四层逻辑架构。分别为交互服务层、流程服务层、场景服务层、量子服务层，颗粒度依次减小。

详见[《S++参考逻辑架构》](./layers.md)  。





