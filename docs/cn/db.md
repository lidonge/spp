# S++分布式数据库需求及参考设计

面向对象从宏观的角度来模拟业务活动，宏观世界对象种类数不胜数，各种关联关系错综复杂，所以这就造成了关系型数据库强大的关系运算能力。而在微观层面，物理世界中庞大的对象种类只剩下有限的几种基本粒子，所以S++从微观角度来模拟业务活动，宏观对象之间的关系就变得基本没有意义了，毕竟父子血缘关系对原子尺度的物质运动应该不会有太多影响。

从S++建模过程中可以发现，支撑模型只需要如下两种数据结构：

- 自然实体存储结构，比如Person，Store等。
- 各种流水信息，用来记录业务事件。

## 基本需求

### 自然实体

- 自然实体需要能够按照NativeID进行检索和存取

  自然实体的存取并没有需求一定要区分实体的类型，比如去访问一个Person数据的时候，其实Person这个数据类型并没有任何实际的帮助。应用只需要知道这是个自然实体，然后根据自然实体的NativeID就可以访问一个Person数据。

- 自然实体之间不存在任何关联，所以对自然实体的任何修改都不必考虑关联的影响。

- 自然实体不需要删除或“消亡”，不参与任何业务活动的自然实体其实就是消亡的实体。

- 如果有按自然实体的属性进行检索需求？那么就需要建立索引文件，而且需要随着属性的改变动态的修改索引。

- 自然实体在单一空间中保持全局单例，无论有多少个应用，自然实体只存在一个实例，所有的修改都必须基于单例进行修改。

- 拥有量子属性的自然实体，可以同时存在于不同的平行空间中。

### 流水（契约）信息

* 流水永远不会被修改
* 流水与实体之间不存在任何关联，流水只是实体活动的凭证和历史记录。
* 流水和流水之间通过流水号进行关联，相同流水号的流水记录的是同一个业务活动的不同部分内容。
* 最基本的检索方式是通过流水号进行检索，如果需要根据契约内容进行检索，就需要建立索引。
* 流水有按照领域进行分区的需求，业务领域是一群业务场景的集合，不同的领域之间可能会有数据隔离的需求。
* 流水是业务活动的体现，业务活动在所有平行空间中都是一致的，所以多平行空间的业务活动只有一套流水记录。

### 索引信息

- 索引是服务，独立于业务数据存在
- 通过索引可以按照业务内容检索实体的RegionID和NativeID，或者是流水信息的流水号。
- 根据需求，索引可以跨区域或者领域，也可以局限于区域或领域内部。
- 索引与流水类似，在自然环境中并不存在，因此索引不需要在多个平行空间中建立副本。

## 核心参考设计

核心参考设计假设存在一个数据库管理程序，用于管理来自S++应用的数据存取和管理需求，这个管理程序被命名为SDBMS。核心参考设计根据S++的特点，将SDBMS按功能垂直划分为实体管理、流水管理、索引管理三大块，同时在服务上按读写的不同水平划分为两部分。

### 分布式与CAP

SDBMS将实体、流水和索引分开存储，同一笔数据（比如一次实体的更新）会异步的去更新实体文件、流水文件和索引文件。即便是数据不存在多个副本，SDBMS依然和传统的关系型数据库有着巨大的不同，关系型数据库会在一次事务操作中完成数据的更新、流水的记录以及索引的更新。所以，SDMMS天然的就具有分布式的特性，尤其是在数据一致性方面，只能提供最终一致性的保证。

SDBMS核心版本中只有数据集中存储方式，数据不存在活跃的副本，任何数据包括实体和流水，都有且只有一份物理实体存在。数据集中方案规定了S++数据存储的基本功能要求，以及设计指标和应用架构要求。数据集中方案是分布式方案的实现基础，如果确实有需要多个活跃数据副本的存在，每一份副本的结构也必须符合同样的数据结构。

基于SDMMS核心版本的应用，可以在S++应用层面提供分布式存储方案，即一次服务请求可以同时发送给多个数据分区。每一个数据分区相当于一个平行空间，多个平行空间保持数据的最终一致性。由于SDBMS在本质上就无法保证数据的强一致性，所以CAP原则中天然的就只能符合AP原则。

### Region空间

SDBMS按Region进行实体空间的分区，每一个Region最多保存2^32个实体，每一个SDBMS中最多有2^32个Region空间。Region之间有两种关系，一种是融合关系，一种是平行关系。具有融合关系的Region共同组成一个更大的Region，具有平行关系的Region是两个不相交的独立平行空间。平行空间之间是保持最终一致性的相似空间（可能数据的存储顺序不同，但是数据的内容完全一致）。融合空间和平行空间最大的区别在于：一个量子活动会同步影响多个平行空间的实体，而融合空间中一个量子活动只可能影响到某一个空间中单个实体。

在S++中，分布式数据是通过拥有最终一致性的多个平行空间实现的，应用本身是无法感知数据拥有多个活动副本的。多个平行空间同时运行带来了更高的效率，不必考虑传统的分布式数据架构中的实时数据在多个副本之间同步的问题，但是同样会带来问题。最主要的问题就是在任意时刻，多个平行空间的数据都可能产生分叉，虽然最终会一致并不会带来严重后果。但是有一种情况值得注意，就是对某个实体属性的并发修改触及阈值而要导致失败，比如最常见的会发生在秒杀场景中。在多个平行空间中，由于订单到来的时序可能是不同的，所以导致在不同空间中因库存耗尽而失败的订单是不同的，从而产生了硬的分叉，影响了最终一致性的达成。解决平行空间硬分叉的问题，在实现过程中可以根据需求，使用不同的解决方案。

### 自然实体存储结构

自然实体按照数据区（Region）文件的方式存储，每一个数据区文件可以存储N（N <= 2^32=4G）个自然实体，SDBMS中存储M（M <= 2^32=4G）个数据区的NativeID索引文件，用于按照NativeID进行检索和访问自然实体。

为了保证对实体进行修改和添加的并发能力，进一步将Region进行划分为1024个块（Block），每一个Block存储4M个实体。由于量子实体和普通实体之间在空间上的差异性，实现中将空间分为量子空间和普通实体空间两种不同的空间，不同的实体只能存储于相应的空间中。

#### Region目录结构

每个数据区包含4种文件：

1. 元数据文件

   元数据文件定义了数据区中所有（一个数据区最多65536种）实体的数据结构，元数据文件是顺序存储的变长结构文件，每一个实体的元数据为一条记录。元数据文件中的记录一旦产生就不可修改，任何实体元数据结构的变更必须保证兼容性（非兼容的变更无法执行）。变更的实体元数据作为一条完整的记录被添加到文件的尾部，SDMMS加载元数据的时候会用后面的定义覆盖前面的定义。实体元数据的数字类型属性有可能被定义为量子属性，当一个属性可能被频繁修改的时候就应该被定义为量子属性，比如数量、金额等易变的属性。

2. 块索引文件

   块索引文件是需要随机存取的定长结构文件，每一个块都有一个索引文件来记录块中每条记录的位置和长度。块索引是需要随机存取的，所以更适合于被保存在能够快速随机存取的介质中，比如SSD。由于介质的不同，所以块索引文件可以与数据文件存在不同的存储目录中。对于需要更高速存取的量子数据索引，可以被保存到内存中。

3. 量子数据块文件

   量子数据一般是实体中快速变化的数据，比如商品的库存量、存款账户中的余额等。为了更高效的更新此类数据，SDBMS中可以将量子类数据单独存储，并且采用定长随机存取的方式。由于量子数据量小，而且需要被高速存取，所以和索引文件一样适合于被保存在SSD中。

4. （非量子）数据块文件

   非量子数据文件用于保存实体中变化缓慢的部分，比如字符串描述等。为了平衡空间和复杂度，非量子数据可以采用随机存取和顺序存取混合模式。

#### 元数据文件

命名："Region"+*regionID*+"_metadata.def"

文件结构：

```
File: 
	Version	: Short(2)
	Modifiler : Short(2) //1 = Region; 2 = Quantum
	RegionOrDomainID : Int(4)
	BlockCount : Short(2)
    MaxMetaID : Short(2)
	Entity_Meta * ;

Entity_Meta :
	ID	 : Short(2) ;
	Name : VarChar ;
    PropSize: Short(2);
	Property_Meta *;

Property_Meta :
	Name : VarChar ;
	Type : Byte;
	Modifiers : Byte;//0x01=Quantum; 0x02=nullable; 0x04=Non-Nagative
    
VarChar ://maximun length 256
	Length : Byte(1);
	Byte[Length];
```

#### 块索引文件

命名："Region"+*regionID*+"_blk" + *blockID* +".idx"

```
File :
	Entity *;
Entity :
	StartPosition : Long(8);
	
```

其中每一个数据块的全部索引大小为(2x2+8)x4M=48M内存空间，对于需要高速存取数据的应用来说，由于索引一旦生成就不会在改变，因此建议直接在内存中加载索引。快索引只针对非量子数据块文件，量子数据块文件由于是定长文件结构，所以不需要额外的索引。

#### 非量子数据块文件

命名："Region"+*regionID*+"_blk" + *blockID* +".dat"

```
File :
	Version	: Short(2)
	RegionOrDomainID : Int(4)
	BlockID : Short(2)
    Entity * ;
Entity :
	Length : Short(2)
	Entity_Meta.ID : Short(2);
	NullStatus : Byte[];
	NotNull_PropertyValue *;
NotNull_PropertyValue :
	ZeroEndString |
	Byte(1)		|
	Short(2) 	|
	Integer(4)	|
	Long(8)		|
	Float(2)	|
	Double(8)	|
	Timestamp(8)	
```

#### 量子数据块文件

命名："Region"+*regionID*+"_blk" + *blockID* +"-Q"+".dat"

```
File :
	Entity *;
Entity :
	QuantumValue *;
QuantumValue :
    Byte(1)		|
    Short(2) 	|
    Integer(4)	|
    Long(8)		|
    Float(2)	|
    Double(8)	|
    Timestamp(8)		
```



#### 自然实体的检索和读取

基于上述的存储结构，自然实体可以通过间接寻址快速的被定位，首先通过RegionID定位数据区，然后根据NativeID/4M定位数据块，再根据NativeID%4M定位实体在索引文件中的记录位置，从索引文件中取得实体的起始地址start_position，以及下一个实体的起始位置以便计算实体字节数大小length，然后从数据块文件中start_position位置开始读取length个字节的实体数据。

可以认为自然实体根据NativeID进行检索的时间复杂度为O(1)。

SDBMS的实体数据一般都会保存在网络存储上，所以任何一个能访问到实体数据文件的节点，都可以启动并注册一个只读的数据服务。

### 业务领域Domain

业务领域由一组在业务上相关的业务场景（scene）组成，业务领域中保存着业务场景所产生的身份契约和可执行契约。与Region类似，每一个Domain最多保存2^32个契约，每一个SDBMS中最多有2^32个Domain。在S++中，Domain对于所有的平行空间都是唯一的，Domain是业务活动的记录档案，是人为的所以并不是客观存在的实体。

由于契约只会增加不会被修改，所以Domain一旦被装满就不会再发生任何改变，如同一个被装满书的书架一样，这样的Domain就可以被归档。对于高并发的读需求的Domain，可以很方便的利用文件同步工具制作备份，因为这些契约一旦被生成就再也不会被修改。

### 流水信息的存储结构

流水的存储结构比自然实体还要简单，因为流水一旦产生就是只读的无需修改。为了防止流水表过于巨大，仿照实体的存储方式，将Domain分割成1024个块，每个块可存储4M个契约。同样为了快速的检索契约，需要一个定长的索引表。

#### Domain目录结构

每个数据区包含3种文件：

1. 元数据文件

   元数据文件定义了数据区中所有（一个数据区最多65536种）契约的数据结构，元数据文件是顺序存储的变长结构文件，每一个契约的元数据为一条记录。元数据文件中的记录一旦产生就不可修改，任何契约元数据结构均无法变更只能签署新的契约。

2. 块索引文件

   Domain的块索引文件与Region块索引结构是一样的。在写方式上有所不同，Domain的块索引需要支持独占模式，对于能保证完全连续的contractID写入的应用，块索引可以采用顺序写以增加写入效率。对于独占写入模式，可以不依赖于高速随机存取的SSD硬件。

3. 契约流水文件

   契约流水文件为顺序写文件，可以满足大批量数据写入。

#### 元数据文件

命名："Domain"+domainID+"_metadata.def"

文件结构：

```
File: 
	Version	: Short(2)
	Modifiler : Short(2) //1 = Region; 2 = Quantum
	RegionOrDomainID : Int(4)
	BlockCount : Short(2)
    MaxMetaID : Short(2)
	Contract_Meta * ;

Contract_Meta :
	ID	 : Integer(2) ;
	Name : VarChar ;	
    PropSize: Short(2);
	Property_Meta *;

Property_Meta :
	Name : VarChar ;
	Type : Byte;
	Modifiers : Byte;//0x02=nullable;
    
VarChar ://maximun length 256
	Length : Byte(1);
	Byte[Length];
```

#### 块索引文件

命名："Domain"+*domainID*+"_blk" + *blockID* +".idx"

```
File :
	Contract *;
Entity :
	StartPosition : Long(8);

```

#### 契约流水文件

命名："Domain"+domainID+"_blk" + *blockID* +".dat"

```
File :
	Version	: Short(2)
	RegionOrDomainID : Int(4)
	BlockID : Short(2)
	Contract *;
Contract :
	Length : Short(2)
    Contract_Meta.ID : Short(2);
	NullStatus : Byte[];
	NotNull_PropertyValue *;
NotNull_PropertyValue :
	ZeroEndString |
	Byte(1)		|
	Short(2) 	|
	Integer(4)	|
	Long(8)		|
	Float(2)	|
	Double(8)	|
	Timestamp(8)	
```

#### 契约流水的检索和读取

基于上述的存储结构，契约流水可以通过间接寻址快速的被定位，首先通过DomainID定位域，然后根据ContractID/4M定位数据块，再根据ContractID%4M定位实体在索引文件中的记录位置，从索引文件中取得实体的起始地址start_position，以及下一个实体的起始位置以便计算实体字节数大小length，然后从数据块文件中start_position位置开始读取length个字节的实体数据。

可以认为自然实体根据NativeID进行检索的时间复杂度为O(1)。

SDBMS的实体数据一般都会保存在网络存储上，所以任何一个能访问到实体数据文件的节点，都可以启动并注册一个只读的数据服务。

### 外部索引服务

索引服务属于S++中的技术服务，可以由独立的第三方应用实现。

## SDBMS微服务设计

SDBMS是一个天然的分布式系统，所有的服务数据库服务都是以微服务的形式运行的，和传统的RDMMS不同的是，并不存在一个统一完整的数据库应用。

### 元数据写入服务

SDMMS中每一个实体空间或者领域，都有一个元数据定义文件，这个文件通过全局文件锁的方式进行元数据的新增和修改，所有的修改都是通过在文件末尾添加新的记录的方式来实现的。

### 元数据读取服务

元数据读取服务并不对外提供服务，而是针对SDBMS中任何需要元数据信息的服务的内置服务。元数据读取服务负责从元数据文件中一次性的加载元数据到内存中，并且定期的根据文件时间戳和大小变化加载新增的元数据。在一个JVM中，元数据读取服务为单例。

### 数据块写服务

为了提高并发能力，SDBMS将空间和域分割成1024个数据块，每个数据块采用单线程处理，并且每个数据块服务只针对单一的客户端。也就是说，任何一个空间和域，最多支持1024个并发同时数据插入。由于这种限制，每一个数据块的索引值都是顺序增长的，所以数据块的索引不需要随机写入能力，和数据块本身一样可以批量的顺序写入。

数据块写缓服务采用生产消费模式，生产者负责处理客户端发送的数据，逐条写入到内存缓存中，当缓存满后将缓存放入一个阻塞队列以便消费者使用；消费者从队列中读出缓存，并将缓存更新到物理文件中。当消费者在固定时间内（比如50毫秒）没有读到已准备好的缓存时，会强制生产者完成当前缓存，并更新物理文件。所以，任何一条数据的插入最长时间就是所配置的超时时间（比如50毫秒）。

生产者会在处理数据的同时产生该记录的索引数据，并由消费者存储索引数据到索引文件中。

数据块写服务通过两种方式保证对数据块文件的锁：一种是管理中心的方式，服务可以从管理中心获得空闲的数据块，并锁定该数据块；或者当管理中心离线的时候，通过全局文件锁的方式保证一个数据块文件只被一个写服务锁定。

### 量子数据更新服务

商业应用中频繁被更新的数据比如库存、余额等都属于量子数据，量子数据只有增加和减小两种量子操作。SDBMS使用定长结构的数据块文件存储量子数据，根据预先定义每一个量子实体占用相同数量的量子空间，量子空间的最小尺寸为8个字节。比如5号空间为量子空间，定义5号空间的量子空间大小为2，则量子数据块文件每条记录的大小为2x8=16个字节。如果要更新实体ID为1367的实体，需要将文件指针移动到2+1367x16的位置，然后根据元数据的定义读取当前数据，进行运算后再写入相同位置。

量子更新服务对块文件的锁与普通数据块写是一样的，所以每一个数据块只会有单一的服务实例访问。与普通数据块不同的是，量子服务允许多个客户端多线程的并发访问。量子服务的生产者是多个线程，他们将要更新的数据存入一个阻塞的队列中，消费者线程不停的从队列中获取数据，计算并存储。

由于量子数据的更新对存储是随机访问的，所以更适合于存储在高速的随机存储中，比如PCIE SSD。