# S++分布式数据库需求及参考设计

面向对象从宏观的角度来模拟业务活动，宏观世界对象种类数不胜数，各种关联关系错综复杂，所以这就造成了关系型数据库强大的关系运算能力。而在微观层面，物理世界中庞大的对象种类只剩下有限的几种基本粒子，所以S++从微观角度来模拟业务活动，宏观对象之间的关系就变得基本没有意义了，毕竟父子血缘关系对原子尺度的物质运动应该不会有太多影响。

从S++建模过程中可以发现，支撑模型只需要如下两种数据结构：

- 自然实体存储结构，比如Person，Store等。
- 各种流水信息，用来记录业务事件。

## 基本需求

### 自然实体

- 自然实体需要能够按照NativeID进行检索和存取

  自然实体的存取并没有需求一定要区分实体的类型，比如去访问一个Person数据的时候，其实Person这个数据类型并没有任何实际的帮助。应用只需要知道这是个自然实体，然后根据自然实体的NativeID就可以访问一个Person数据。

- 自然实体之间不存在任何关联，所以对自然实体的任何修改都不必考虑关联的影响。

- 自然实体不需要删除或“消亡”，不参与任何业务活动的自然实体其实就是消亡的实体。

- 如果有按自然实体的属性进行检索需求？那么就需要建立索引文件，而且需要随着属性的改变动态的修改索引。

- 自然实体在单一空间中保持全局单例，无论有多少个应用，自然实体只存在一个实例，所有的修改都必须基于单例进行修改。

- 自然实体可以同时存在于不同的平行空间中。

### 流水（契约）信息

* 流水永远不会被修改
* 流水与实体之间不存在任何关联，流水只是实体活动的凭证和历史记录。
* 流水和流水之间通过流水号进行关联，相同流水号的流水记录的是同一个业务活动的不同部分内容。
* 最基本的检索方式是通过流水号进行检索，如果需要根据契约内容进行检索，就需要建立索引。
* 流水有按照领域进行分区的需求，业务领域是一群业务场景的集合，不同的领域之间可能会有数据隔离的需求。
* 流水是业务活动的体现，业务活动在所有平行空间中都是一致的，所以多平行空间的业务活动只有一套流水记录。

### 索引信息

- 索引是服务，独立于业务数据存在
- 通过索引可以按照业务内容检索实体的RegionID和NativeID，或者是流水信息的流水号。
- 根据需求，所以可以跨区域或者领域，也可以局限于区域或领域内部。
- 索引与流水类似，在自然环境中并不存在，因此索引不需要在多个平行空间中建立副本。

## 核心参考设计

核心参考设计假设存在一个数据库管理程序，用于管理来自S++应用的数据存取和管理需求，这个管理程序被命名为SDBMS。核心参考设计根据S++的特点，将SDBMS按功能垂直划分为实体管理、流水管理、索引管理三大块，同时在服务上按读写的不同水平划分为两部分。

### 分布式与CAP

SDBMS将实体、流水和索引分开存储，同一笔数据（比如一次实体的更新）会异步的去更新实体文件、流水文件和索引文件。即便是数据不存在多个副本，SDBMS依然和传统的关系型数据库有着巨大的不同，关系型数据库会在一次事务操作中完成数据的更新、流水的记录以及索引的更新。所以，SDMMS天然的就具有分布式的特性，尤其是在数据一致性方面，只能提供最终一致性的保证。

SDBMS核心版本中只有数据集中存储方式，数据不存在活跃的副本，任何数据包括实体和流水，都有且只有一份物理实体存在。数据集中方案规定了S++数据存储的基本功能要求，以及设计指标和应用架构要求。数据集中方案是分布式方案的实现基础，如果确实有需要多个活跃数据副本的存在，每一份副本的结构也必须符合同样的数据结构。

基于SDMMS核心版本的应用，可以在S++应用层面提供分布式存储方案，即一次服务请求可以同时发送给多个数据分区。每一个数据分区相当于一个平行空间，多个平行空间保持数据的最终一致性。由于SDBMS在本质上就无法保证数据的强一致性，所以CAP原则中天然的就只能符合AP原则。

### Region空间

SDBMS按Region进行实体空间的分区，每一个Region最多保存2^32个实体，每一个SDBMS中最多有2^32个Region空间。Region之间有两种关系，一种是融合关系，一种是平行关系。具有融合关系的Region共同组成一个更大的Region，具有平行关系的Region是两个不相交的独立平行空间。平行空间之间是保持最终一致性的相似空间（可能数据的存储顺序不同，但是数据的内容完全一致）。融合空间和平行空间最大的区别在于：一个量子活动会同步影响多个平行空间的实体，而融合空间中一个量子活动只可能影响到某一个空间中单个实体。

在S++中，分布式数据是通过拥有最终一致性的多个平行空间实现的，应用本身是无法感知数据拥有多个活动副本的。多个平行空间同时运行带来了更高的效率，不必考虑传统的分布式数据架构中的实时数据在多个副本之间同步的问题，但是同样会带来问题。最主要的问题就是在任意时刻，多个平行空间的数据都可能产生分叉，虽然最终会一致并不会带来严重后果。但是有一种情况值得注意，就是对某个实体属性的并发修改触及阈值而要导致失败，比如最常见的会发生在秒杀场景中。在多个平行空间中，由于订单到来的时序可能是不同的，所以导致在不同空间中因库存耗尽而失败的订单是不同的，从而产生了硬的分叉，影响了最终一致性的达成。解决平行空间硬分叉的问题，在实现过程中可以根据需求，使用不同的解决方案。

### 自然实体存储结构

自然实体按照数据区（Region）文件的方式存储，每一个数据区文件可以存储N（N <= 2^32=4G）个自然实体，SDBMS中存储M（M <= 2^32=4G）个数据区的NativeID索引文件，用于按照NativeID进行检索和访问自然实体。

为了保证对实体进行修改和添加的并发能力，进一步将Region进行划分为1024个块（Block），每一个Block存储4M个实体。

#### Region目录结构

每个数据区包含4种文件：

1. 元数据文件

   元数据文件定义了数据区中所有（一个数据区最多65536种）实体的数据结构，元数据文件是顺序存储的变长结构文件，每一个实体的元数据为一条记录。元数据文件中的记录一旦产生就不可修改，任何实体元数据结构的变更必须保证兼容性（非兼容的变更无法执行）。变更的实体元数据作为一条完整的记录被添加到文件的尾部，SDMMS加载元数据的时候会用后面的定义覆盖前面的定义。实体元数据的数字类型属性有可能被定义为量子属性，当一个属性可能被频繁修改的时候就应该被定义为量子属性，比如数量、金额等易变的属性。

2. 块索引文件

   块索引文件是需要随机存取的定长结构文件，每一个块都有一个索引文件来记录块中每条记录的位置和长度。块索引是需要随机存取的，所以更适合于被保存在能够快速随机存取的介质中，比如SSD。由于介质的不同，所以块索引文件可以与数据文件存在不同的存储目录中。对于需要更高速存取的量子数据索引，可以被保存到内存中。

3. 量子数据块文件

   量子数据一般是实体中快速变化的数据，比如商品的库存量、存款账户中的余额等。为了更高效的更新此类数据，SDBMS中可以将量子类数据单独存储，并且采用定长随机存取的方式。由于量子数据量小，而且需要被高速存取，所以和索引文件一样适合于被保存在SSD中。

4. （非量子）数据块文件

   非量子数据文件用于保存实体中变化缓慢的部分，比如字符串描述等。为了平衡空间和复杂度，非量子数据可以采用随机存取和顺序存取混合模式。

#### 元数据文件

命名："Region"+*regionID*+"_metadata.def"

文件结构：

```
File: 
	Version	: Short(2)
	MaxMetaID : Short(2)
	Entity_Meta * ;

Entity_Meta :
	ID	 : Short(2) ;
	Name : VarChar ;
    PropSize: Short(2);
	Property_Meta *;

Property_Meta :
	Name : VarChar ;
	Type : Byte;
	Modifiers : Byte;//0x01=Quantum; 0x02=nullable; 0x04=Non-Nagative
    
VarChar ://maximun length 256
	Length : Byte(1);
	Byte[Length];
```

#### 块索引文件

命名："Region"+*regionID*+"_blk" + *blockID* +".idx"

```
File :
	Version	: Short(2)
	IndexSize : byte(1)//the value is 2
	Entity *;
Entity :
	Entity_Meta.ID : Short(2);
	StartPosition : Long(8);
	Length : Short(2)
	
```

其中每一个数据块的全部索引大小为(2x2+8)x4M=48M内存空间，对于需要高速存取数据的应用来说，由于索引一旦生成就不会在改变，因此建议直接在内存中加载索引。

#### 非量子数据块文件

命名："Region"+*regionID*+"_blk" + *blockID* +".dat"

```
File :
	Version	: Short(2)
	Entity * ;
Entity :
	NullStatus : Byte[];
	NotNull_PropertyValue *;
NotNull_PropertyValue :
	ZeroEndString |
	Byte(1)		|
	Short(2) 	|
	Integer(4)	|
	Long(8)		|
	Float(2)	|
	Double(8)	|
	Timestamp(8)	
```

#### 量子数据块文件

命名："Region"+*regionID*+"_blk" + *blockID* +"-Q"+".dat"

```
File :
	Version	: Short(2)
	Entity *;
Entity :
	QuantumValue *;
QuantumValue :
    Byte(1)		|
    Short(2) 	|
    Integer(4)	|
    Long(8)		|
    Float(2)	|
    Double(8)	|
    Timestamp(8)		
```



#### 自然实体的检索和读取

基于上述的存储结构，自然实体可以通过间接寻址快速的被定位，首先通过RegionID定位数据区，然后根据NativeID/4M定位数据块，再根据NativeID%4M定位实体在索引文件中的记录位置，从索引文件中取得实体的起始地址start_position，以及下一个实体的起始位置以便计算实体字节数大小length，然后从数据块文件中start_position位置开始读取length个字节的实体数据。

可以认为自然实体根据NativeID进行检索的时间复杂度为O(1)。

SDBMS的实体数据一般都会保存在网络存储上，所以任何一个能访问到实体数据文件的节点，都可以启动并注册一个只读的数据服务。

#### 并发处理规则

一个Region同时只允许一个维护进程进行修改，允许多个消费进程读取。

元数据文件维护服务属于低频操作，在维护进程中可以简化为单例单线程。

非量子数据更新和插入，也属于相对低频操作。可以为每个活动的block分配一个线程。

量子数据的更新，每一个活动block占用一个线程，对block数据文件进行随机读写。所有并发请求先写入阻塞队列进行缓存，然后由处理线程逐一处理随机写入文件。这就要求，队列中的数据尽可能为最简单的数据，避免多余的处理时间。

### 业务领域Domain

业务领域由一组在业务上相关的业务场景（scene）组成，业务领域中保存着业务场景所产生的身份契约和可执行契约。与Region类似，每一个Domain最多保存2^32个契约，每一个SDBMS中最多有2^32个Domain。在S++中，Domain对于所有的平行空间都是唯一的，Domain是业务活动的记录档案，是人为的所以并不是客观存在的实体。

由于契约只会增加不会被修改，所以Domain一旦被装满就不会再发生任何改变，如同一个被装满书的书架一样，这样的Domain就可以被归档。对于高并发的读需求的Domain，可以很方便的利用文件同步工具制作备份，因为这些契约一旦被生成就再也不会被修改。

### 流水信息的存储结构

流水的存储结构比自然实体还要简单，因为流水一旦产生就是只读的无需修改。为了防止流水表过于巨大，仿照实体的存储方式，将Domain分割成1024个块，每个块可存储4M个契约。同样为了快速的检索契约，需要一个定长的索引表。

#### Domain目录结构

每个数据区包含3种文件：

1. 元数据文件

   元数据文件定义了数据区中所有（一个数据区最多65536种）契约的数据结构，元数据文件是顺序存储的变长结构文件，每一个契约的元数据为一条记录。元数据文件中的记录一旦产生就不可修改，任何契约元数据结构均无法变更只能签署新的契约。

2. 块索引文件

   Domain的块索引文件与Region块索引结构是一样的。在写方式上有所不同，Domain的块索引需要支持独占模式，对于能保证完全连续的contractID写入的应用，块索引可以采用顺序写以增加写入效率。对于独占写入模式，可以不依赖于高速随机存取的SSD硬件。

3. 契约流水文件

   契约流水文件为顺序写文件，可以满足大批量数据写入。

#### 元数据文件

命名："Domain"+domainID+"_metadata.def"

文件结构：

```
File: 
	Version	: Short(2)
	Contract_Meta * ;

Contract_Meta :
	ID	 : Integer(2) ;
	Name : VarChar ;	
    PropSize: Short(2);
	Property_Meta *;

Property_Meta :
	Name : VarChar ;
	Type : Byte;
	Modifiers : Byte;//0x02=nullable;
    
VarChar ://maximun length 256
	Length : Byte(1);
	Byte[Length];
```

#### 块索引文件

命名："Domain"+*domainID*+"_blk" + *blockID* +".idx"

```
File :
	Version	: Short(2)
	IndexSize : byte(1)//the value is 1
	Contract *;
Entity :
	Contract_Meta.ID : Short(2);
	StartPosition : Long(8);
	Length : Short(2)
```

#### 契约流水文件

命名："Domain"+domainID+"_blk" + *blockID* +".dat"

```
File :
	Version	: Short(2)
	Contract *;
Contract :
	NullStatus : Byte[];
	NotNull_PropertyValue *;
NotNull_PropertyValue :
	ZeroEndString |
	Byte(1)		|
	Short(2) 	|
	Integer(4)	|
	Long(8)		|
	Float(2)	|
	Double(8)	|
	Timestamp(8)	
```

#### 契约流水的检索和读取

基于上述的存储结构，契约流水可以通过间接寻址快速的被定位，首先通过DomainID定位域，然后根据ContractID/4M定位数据块，再根据ContractID%4M定位实体在索引文件中的记录位置，从索引文件中取得实体的起始地址start_position，以及下一个实体的起始位置以便计算实体字节数大小length，然后从数据块文件中start_position位置开始读取length个字节的实体数据。

可以认为自然实体根据NativeID进行检索的时间复杂度为O(1)。

SDBMS的实体数据一般都会保存在网络存储上，所以任何一个能访问到实体数据文件的节点，都可以启动并注册一个只读的数据服务。

#### 并发处理规则

一个Domain同时只允许一个维护进程进行修改，允许多个消费进程读取。

元数据文件维护服务属于低频操作，在维护进程中可以简化为单例单线程。

契约流水的独占模式中，在同一个block中要求保持contractID的连续性，所以一个block只能被一个客户端使用，每一个domain只能同时有1024个客户端连接。



### 外部索引服务

索引服务属于S++中的技术服务，可以由独立的第三方应用实现。

### 